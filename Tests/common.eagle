###############################################################################
#
# common.eagle --
#
# Written by Joe Mistachkin.
# Released to the public domain, use at your own risk!
#
###############################################################################

if {[isEagle]} then {
  proc getAssemblyFileName { fileName } {
    return [file join [file dirname $::path] bin \
        [expr {[haveConstraint imageRuntime40] ? "2010" : "2008"}] \
        $::test_configuration bin $fileName]
  }

  proc copyAssembly { fileName } {
    #
    # NOTE: If we cannot copy the file then it is probably already loaded,
    #       ignore the error.
    #
    catch {
      file copy -force [getAssemblyFileName $fileName] \
          [file join [info binary] $fileName]
    }
  }

  proc loadAssembly { fileName } {
    set fileName [getAssemblyFileName $fileName]

    if {[catch {set assembly \
        [object load -loadtype File $fileName]}] == 0} then {
      #
      # NOTE: Now, add the necessary test constraint.
      #
      addConstraint [file rootname [file tail $fileName]]

      #
      # NOTE: Return the full path of the loaded file.
      #
      return $fileName
    }

    return ""
  }

  proc compileCSharpWith { text resultsVarName errorsVarName fileNames args } {
    #
    # NOTE: Create the base command to evaluate and add the property settings
    #       that are almost always needed by our unit tests (i.e. the System
    #       and System.Data assembly references).
    #
    set command [list compileCSharp $text results errors \
        ReferencedAssemblies.Add System.dll ReferencedAssemblies.Add \
        System.Data.dll]

    #
    # NOTE: Add all the provided file names as assembly references.
    #
    foreach fileName $fileNames {
      lappend command ReferencedAssemblies.Add [getAssemblyFileName $fileName]
    }

    #
    # NOTE: Add the extra arguments, if any, to the command to evaluate.
    #
    eval lappend command $args

    #
    # NOTE: Alias the compiler local results and errors variables to the
    #       variable names provided by our caller.
    #
    upvar 1 $resultsVarName results
    upvar 1 $errorsVarName errors

    #
    # NOTE: Evaluate the constructed [compileCSharp] command and return the
    #       result.
    #
    eval $command
  }

  proc setupDb {fileName {mode ""} {delete ""} {extra ""} {varName db}} {
    set fileName [file join [getTemporaryPath] $fileName]

    if {[string length $delete] == 0 || $delete} then {
      catch {file delete $fileName}
    }

    upvar 1 $varName db

    set connection {Data Source=${fileName}}

    if {[string length $mode] > 0} then {
      append connection {;Journal Mode=${mode}}
    }

    if {[string length $extra] > 0} then {
      append connection \; $extra
    }

    set db [sql open -type SQLite [subst $connection]]
  }

  proc cleanupDb {fileName {varName db}} {
    upvar 1 $varName db
    catch {sql close $db}
    catch {file delete [file join [getTemporaryPath] $fileName]}
  }
}
